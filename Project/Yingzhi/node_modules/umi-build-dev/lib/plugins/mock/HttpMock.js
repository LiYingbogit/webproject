"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _path = require("path");

var _fs = require("fs");

var _chalk = _interopRequireDefault(require("chalk"));

var _assert = _interopRequireDefault(require("assert"));

var _bodyParser = _interopRequireDefault(require("body-parser"));

var _chokidar = _interopRequireDefault(require("chokidar"));

var _glob = _interopRequireDefault(require("glob"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function MOCK_START(req, res, next) {
  next();
}

function MOCK_END(req, res, next) {
  next();
}

class HttpMock {
  constructor({
    cwd,
    app,
    api
  }) {
    this.app = app;
    this.api = api;
    this.absMockPath = (0, _path.join)(cwd, 'mock');
    this.configPath = (0, _path.join)(cwd, '.umirc.mock.js');
    this.api.registerBabel([this.configPath, this.absMockPath]);
    this.applyMock();
    this.watch();
  }

  applyMock(isWatch) {
    try {
      this.realApplyMock(isWatch);
    } catch (e) {
      console.error(_chalk.default.red(`mock failed: ${e.message}`));
    }
  }

  watch() {
    if (process.env.WATCH_FILES === 'none') return;
    const debug = this.api.utils.debug;

    const watcher = _chokidar.default.watch([this.configPath, this.absMockPath], {
      ignoreInitial: true
    });

    watcher.on('all', (event, file) => {
      debug(`[${event}] ${file}`);
      this.applyMock(
      /* isWatch */
      true);
    });
  }
  /**
   * Delete from MOCK_START to MOCK_END
   */


  deleteRoutes() {
    const app = this.app,
          debug = this.api.utils.debug;
    let startIndex = null;
    let endIndex = null;

    app._router.stack.forEach((item, index) => {
      if (item.name === 'MOCK_START') startIndex = index;
      if (item.name === 'MOCK_END') endIndex = index;
    });

    if (startIndex !== null && endIndex !== null) {
      app._router.stack.splice(startIndex, endIndex - startIndex + 1);
    }

    debug(`routes after changed: ${app._router.stack.map(item => item.name || 'undefined name').join(', ')}`);
  }

  realApplyMock(isWatch) {
    const debug = this.api.utils.debug;
    const config = this.getConfig();
    debug(`config: ${JSON.stringify(config)}`);
    const app = this.app;
    let startIndex = null;
    let endIndex = null;
    let routesLength = null;

    if (isWatch) {
      app._router.stack.forEach((item, index) => {
        if (item.name === 'MOCK_START') startIndex = index;
        if (item.name === 'MOCK_END') endIndex = index;
      });

      if (startIndex !== null && endIndex !== null) {
        app._router.stack.splice(startIndex, endIndex - startIndex + 1);
      }

      routesLength = app._router.stack.length;
    }

    app.use(MOCK_START);
    app.use(_bodyParser.default.json({
      limit: '5mb',
      strict: false
    }));
    app.use(_bodyParser.default.urlencoded({
      extended: true,
      limit: '5mb'
    }));
    Object.keys(config).forEach(key => {
      const keyParsed = this.parseKey(key);
      (0, _assert.default)(!!app[keyParsed.method], `method of ${key} is not valid`);
      (0, _assert.default)(typeof config[key] === 'function' || typeof config[key] === 'object', `mock value of ${key} should be function or object, but got ${typeof config[key]}`);
      app[keyParsed.method](keyParsed.path, this.createMockHandler(keyParsed.method, keyParsed.path, config[key]));
    });
    app.use(MOCK_END);

    if (isWatch) {
      const newRoutes = app._router.stack.splice(routesLength, app._router.stack.length - routesLength);

      app._router.stack.splice(startIndex, 0, ...newRoutes);
    } // 调整 stack，把 UMI_PLUGIN_404 放到最后


    debug(`routes after resort: ${app._router.stack.map(item => item.name || 'undefined name').join(', ')}`);
  }

  createMockHandler(method, path, value) {
    return function mockHandler(...args) {
      const res = args[1];

      if (typeof value === 'function') {
        value(...args);
      } else {
        res.json(value);
      }
    };
  }

  parseKey(key) {
    let method = 'get';
    let path = key;

    if (key.indexOf(' ') > -1) {
      const splited = key.split(' ');
      method = splited[0].toLowerCase();
      path = splited[1]; // eslint-disable-line
    }

    return {
      method,
      path
    };
  }

  disableRequireCache() {
    Object.keys(require.cache).forEach(file => {
      if (file === this.configPath || file.indexOf(this.absMockPath) > -1) {
        delete require.cache[file];
      }
    });
  }

  getConfig() {
    const debug = this.api.utils.debug;

    if ((0, _fs.existsSync)(this.configPath)) {
      this.disableRequireCache();
      return require(this.configPath); // eslint-disable-line
    } else if ((0, _fs.existsSync)(this.absMockPath)) {
      this.disableRequireCache();

      const mockFiles = _glob.default.sync('**/*.js', {
        cwd: this.absMockPath
      });

      debug(`mockFiles: ${JSON.stringify(mockFiles)}`);
      return mockFiles.reduce((memo, mockFile) => {
        memo = _objectSpread({}, memo, require((0, _path.join)(this.absMockPath, mockFile)));
        return memo;
      }, {});
    } else {
      return {};
    }
  }

}

var _default = HttpMock;
exports.default = _default;